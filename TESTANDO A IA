import os
import torch
import torchvision.transforms as transforms
from PIL import Image
import matplotlib.pyplot as plt
import torchvision.models.segmentation as segmentation
import numpy as np

# Caminhos para a imagem de teste
test_image_path = r'c:\Users\João Vitor\Downloads\test_img\test4.jpg'

# Definindo as transformações para a imagem de teste
transform = transforms.Compose([
    transforms.Resize((256, 256)),
    transforms.ToTensor()
])

# Carregando o modelo DeepLabV3
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = segmentation.deeplabv3_resnet101(pretrained=False, num_classes=21)  # Ajuste num_classes conforme necessário
model.to(device)

# Carregando os pesos do modelo treinado
checkpoint_path = 'best_model.pth.tar'
if os.path.exists(checkpoint_path):
    model.load_state_dict(torch.load(checkpoint_path))
    print(f'Modelo carregado a partir de {checkpoint_path}.')
else:
    raise FileNotFoundError(f'O arquivo {checkpoint_path} não foi encontrado.')

# Preparando a imagem de teste
test_image = Image.open(test_image_path).convert('RGB')
test_image = transform(test_image).unsqueeze(0).to(device)  # Adicionando uma dimensão para o batch

# Realizando a inferência
model.eval()
with torch.no_grad():
    output = model(test_image)['out']
    output = torch.argmax(output, dim=1).squeeze().cpu().numpy()

# Exibindo a imagem testada e a saída
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.title('Imagem Original')
plt.imshow(test_image.squeeze().cpu().permute(1, 2, 0))
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title('Resultado da Segmentação')
plt.imshow(output, cmap='gray')
plt.axis('off')

plt.show()import os
import torch
import torchvision.transforms as transforms
from PIL import Image
import matplotlib.pyplot as plt
import torchvision.models.segmentation as segmentation
import numpy as np

# Caminhos para a imagem de teste
test_image_path = r'c:\Users\João Vitor\Downloads\test_img\test4.jpg'

# Definindo as transformações para a imagem de teste
transform = transforms.Compose([
    transforms.Resize((256, 256)),
    transforms.ToTensor()
])

# Carregando o modelo DeepLabV3
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = segmentation.deeplabv3_resnet101(pretrained=False, num_classes=21)  # Ajuste num_classes conforme necessário
model.to(device)

# Carregando os pesos do modelo treinado
checkpoint_path = 'best_model.pth.tar'
if os.path.exists(checkpoint_path):
    model.load_state_dict(torch.load(checkpoint_path))
    print(f'Modelo carregado a partir de {checkpoint_path}.')
else:
    raise FileNotFoundError(f'O arquivo {checkpoint_path} não foi encontrado.')

# Preparando a imagem de teste
test_image = Image.open(test_image_path).convert('RGB')
test_image = transform(test_image).unsqueeze(0).to(device)  # Adicionando uma dimensão para o batch

# Realizando a inferência
model.eval()
with torch.no_grad():
    output = model(test_image)['out']
    output = torch.argmax(output, dim=1).squeeze().cpu().numpy()

# Exibindo a imagem testada e a saída
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.title('Imagem Original')
plt.imshow(test_image.squeeze().cpu().permute(1, 2, 0))
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title('Resultado da Segmentação')
plt.imshow(output, cmap='gray')
plt.axis('off')

plt.show()
