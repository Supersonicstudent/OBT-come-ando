import cv2
import numpy as np
import matplotlib.pyplot as plt
from skimage.metrics import structural_similarity as ssim

def preprocess_image(image):
    # Aplicar um filtro de mediana para suavizar a imagem e reduzir o ruído
    return cv2.medianBlur(image, 5)

def kmeans_segmentation(image_path, k=3, kernel_size=3):
    # Verificar se o tamanho do kernel é válido
    if kernel_size < 1:
        raise ValueError("O tamanho do kernel deve ser um número inteiro positivo maior que zero.")
    
    # Carregar a imagem
    image = cv2.imread(image_path)
    
    # Verificar se a imagem foi carregada com sucesso
    if image is None:
        print(f"Erro ao carregar a imagem. Verifique o caminho do arquivo: {image_path}")
        return
    
    # Pré-processar a imagem
    image = preprocess_image(image)
    
    # Converter a imagem para o espaço de cores RGB
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    
    # Converter a imagem RGB para um formato de dados 2D
    pixels = image_rgb.reshape(-1, 3)
    
    # Aplicar o algoritmo K-means
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)
    _, labels, centers = cv2.kmeans(pixels.astype(np.float32), k, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)
    
    # Converter os centros para inteiros
    centers = np.uint8(centers)
    
    # Recriar a imagem segmentada
    segmented_image = centers[labels.flatten()]
    segmented_image = segmented_image.reshape(image_rgb.shape)
    
    # Converter a imagem segmentada em escala de cinza
    segmented_gray = cv2.cvtColor(segmented_image, cv2.COLOR_RGB2GRAY)
    
    # Definir a faixa de cinza a ser convertida para branco
    lower_gray = 120
    upper_gray = 170
    
    # Converter pixels de cinza na faixa para branco (255)
    segmented_gray[(segmented_gray >= lower_gray) & (segmented_gray <= upper_gray)] = 255
    
    # Aplicar uma binarização para criar uma máscara
    _, mask = cv2.threshold(segmented_gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    
    # Ajustar o tamanho do kernel
    kernel = np.ones((kernel_size, kernel_size), np.uint8)
    
    # Aplicar operações morfológicas para refinar a máscara
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
    
    # Encontrar contornos
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # Criar uma máscara final onde as ruas serão brancas e o resto será preto
    final_mask = np.zeros_like(mask)
    cv2.drawContours(final_mask, contours, -1, (255), thickness=cv2.FILLED)
    
    return segmented_image, final_mask

def evaluate_segmentation(original_image, segmented_image, original_mask, segmented_mask):
    # Converter a máscara original para escala de cinza se necessário
    if original_mask.ndim == 3:
        original_mask = cv2.cvtColor(original_mask, cv2.COLOR_RGB2GRAY)
    
    # Converter a máscara segmentada para escala de cinza se necessário
    if segmented_mask.ndim == 3:
        segmented_mask = cv2.cvtColor(segmented_mask, cv2.COLOR_RGB2GRAY)
    
    # Calcular SSIM entre a imagem original e a imagem segmentada
    ssim_score, _ = ssim(original_image, segmented_image, win_size=11, full=True, channel_axis=-1)
    print(f"SSIM: {ssim_score}")

    # Calcular IoU entre duas máscaras binárias
    intersection = np.logical_and(original_mask, segmented_mask)
    union = np.logical_or(original_mask, segmented_mask)
    iou_score = np.sum(intersection) / np.sum(union)
    print(f"IoU: {iou_score}")

    # Visualizar as imagens para comparação
    plt.figure(figsize=(15, 10))

    plt.subplot(2, 3, 1)
    plt.title('Original Image')
    plt.imshow(original_image)
    plt.axis('off')

    plt.subplot(2, 3, 2)
    plt.title('Segmented Image')
    plt.imshow(segmented_image)
    plt.axis('off')

    plt.subplot(2, 3, 3)
    plt.title('Original Mask')
    plt.imshow(original_mask, cmap='gray')
    plt.axis('off')

    plt.subplot(2, 3, 4)
    plt.title('Segmented Mask')
    plt.imshow(segmented_mask, cmap='gray')
    plt.axis('off')

    plt.subplot(2, 3, 5)
    plt.title('Intersection')
    plt.imshow(intersection, cmap='gray')
    plt.axis('off')

    plt.subplot(2, 3, 6)
    plt.title('Union')
    plt.imshow(union, cmap='gray')
    plt.axis('off')

    plt.tight_layout()
    plt.show()

# Substitua pelo caminho real da imagem
image_path = r'C:\Users\steve\OneDrive\Documents\Local do engarrafamento.jpg'

# Exemplo de uso
original_image = cv2.imread(image_path)
original_image = cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB)
original_mask = preprocess_image(original_image)

segmented_image, segmented_mask = kmeans_segmentation(image_path, k=3, kernel_size=1)

# Avaliar a segmentação
evaluate_segmentation(original_image, segmented_image, original_mask, segmented_mask)
